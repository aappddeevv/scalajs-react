(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{77:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return i}),n.d(t,"rightToc",function(){return l}),n.d(t,"default",function(){return p});n(0);var a=n(89);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i={id:"react_native",title:"React Native"},l=[{value:"Setup",id:"setup",children:[]},{value:"Enhanced Setup",id:"enhanced-setup",children:[]},{value:"Calling AppRegistry.registerComponent in scala.js",id:"calling-appregistryregistercomponent-in-scalajs",children:[]},{value:"Build",id:"build",children:[]},{value:"Helpers",id:"helpers",children:[]},{value:"Other Libraries",id:"other-libraries",children:[]},{value:"Resources",id:"resources",children:[]},{value:"Result",id:"result",children:[]}],s={rightToc:l},c="wrapper";function p(e){var t=e.components,n=o(e,["components"]);return Object(a.b)(c,r({},s,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,'You can easily create react native applications using this library. react native\nuses a "runner" application (unlike flutter) to host the javascript execution\nengine. You will need the runner skeleton to build a react native\napplication. The best way to do that is to follow the instructions for\ninstalling\n',Object(a.b)("a",r({parentName:"p"},{href:"https://facebook.github.io/react-native/docs/getting-started"}),Object(a.b)("inlineCode",{parentName:"a"},"react-native-cli")),"\nand then overlaying the scalajs library on top of the generated project."),Object(a.b)("h2",null,Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"setup"})),Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#setup"}),"#"),"Setup"),Object(a.b)("p",null,"To overlay the scala.js parts (until I create a nice g8 template with this\nalready in it):"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Create build.sbt as you normally would."),Object(a.b)("li",{parentName:"ul"},"Create the project folder as you normally would."),Object(a.b)("li",{parentName:"ul"},"Create source folder ",Object(a.b)("inlineCode",{parentName:"li"},"mkdir -p src/main/scala")," content at the top-level.")),Object(a.b)("p",null,"Include the core libraries:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-scala"}),'scalajsReactVersion = ...\nlibraryDependencies ++= Seq(\n    "ttg" %%% "scalajs-reaction-core" % scalajsReactVersion,\n    "ttg" %%% "scalajs-reaction-native" % scalajsReactVersion\n)\n')),Object(a.b)("p",null,"in your library dependencies. Create your build.sbt build file as you would for\nany scala project including scala flags, etc. You can copy portions of the build.sbt file at ",Object(a.b)("a",r({parentName:"p"},{href:"https://github.com/aappddeevv/scalajs-react-app.g8"}),"scala.js react template"),"."),Object(a.b)("p",null,'Alter the index.js in the top level directory to either contain the "exported to\njs" component ',Object(a.b)("em",{parentName:"p"},"or")," you can call ",Object(a.b)("inlineCode",{parentName:"p"},"AppRegistry.registerComponent")," inside of\nscalajs. The scala.js function that you would call in index.js must be top level\nexported (",Object(a.b)("inlineCode",{parentName:"p"},"@JSExportTopLevel"),'). In either case, the index.js should either use\nyour exported JS "app" component or call a function that calls\n',Object(a.b)("inlineCode",{parentName:"p"},"registerComponent"),"."),Object(a.b)("p",null,"You may want to include ",Object(a.b)("inlineCode",{parentName:"p"},'"org.scala-js" %%% "scala-js-dom" % "latest.version"'),"\nto include scala support for some of the available polyfills such as\n",Object(a.b)("inlineCode",{parentName:"p"},"fetch"),". There is no DOM on the mobile devices, so the DOM parts of this library\nare not available and you should not use them."),Object(a.b)("p",null,"That's all you need for setup to get started."),Object(a.b)("h2",null,Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"enhanced-setup"})),Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#enhanced-setup"}),"#"),"Enhanced Setup"),Object(a.b)("p",null,"If you want to copy your scalajs output to a well known location so that you\nonly need to change your index.js (located in the toplevel directory) once, you\ncan set up a file copy task that copies the output of fullOptJS or\nfastOptJS. You would run this task after the scala.js full/fast\nprocessing. index.js is the default starting point for javascript bundling when\nusing the react-native cli such as ",Object(a.b)("inlineCode",{parentName:"p"},"react-native run-android"),". "),Object(a.b)("p",null,"The metro bundler looks for index.js to create the javascript resource\ngraph. Instead of modifying the output of sbt, you can also use build vars in\njavascript to switch between targets--a typical approach in javascript\ne.g. include min if you are in a dev build. Below is the copy approach. If your\nfinal scala.js project that creates the linked javascript artifact is always the\nsame, it is probably easier to hardcode the path with conditionals in index.js."),Object(a.b)("p",null,"However, let's just assume that you want to keep index.js unchanged and want to\nmap full or fast builds to the same output file."),Object(a.b)("p",null,"You will want to scope the task to the respective scala.js linkage tasks,\nfastOptJS or fullOptJS so that the correct artifactPath is picked up."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-scala"}),'lazy val root = ...\n  //...\n  // rename outputs\n  .settings(artifactPath.in(Compile, fastOptJS) := crossTarget.in(Compile, fastOptJS).value / "Scala.js")\n  .settings(artifactPath.in(Compile, fullOptJS) := crossTarget.in(Compile, fullOptJS).value / "Scala.js")\n\n// Copy output to the current dir, which is where build.sbt runs.\n// Could use another directory as well e.g. src or dist\nval copyOutputDir = "."\n\ndef copyJSAndMap(src: File): Unit = {\n  println(s"Copying: [$src] to [$copyOutputDir]")\n  val outputName = src.name\n  val mapOutputName = src.name + ".map"\n  IO.copyFile(src, file(outputName), true, true)\n  IO.copyFile(file(src.getCanonicalPath() + ".map"), file(mapOutputName), true, true)\n}\n\nlazy val copyJSOutput = taskKey[Unit]("copy scala.js output to well known location")\n\n// no scoping as we use scalaJSLinkedFile, which is independent of *OptJS,\n// instead of artifactPath which is dependent on a specific *OptJS\ncopyJSOutput := {\n  val infile = scalaJSLinkedFile.in(Compile).value.path\n  copyJSAndMap(file(infile))\n\n}\n\n// trigger the copy after an *OptJS task is run\n// depending on project structure, scope to the project\n// run a clean before switching targets\nfastOptJS / copyJSOutput := (copyJSOutput triggeredBy fastOptJS.in(Compile)).value\nfullOptJS / copyJSOutput := (copyJSOutput triggeredBy fullOptJS.in(Compile)).value\n')),Object(a.b)("p",null,"There are many ways to do this in sbt including using artifactPath (scoped to\nthe fast or full task inside Compile) to copy the file and standardize its output\nname for react-native."),Object(a.b)("p",null,"If you need to copy per task you could also create a plugin or do something\nsmall like:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-scala"}),'def copyTask(odir: String) = {\n  //lazy val copyOutputDir = settingKey[String]("target directory for copying output to")\n  lazy val copyJSOutput = taskKey[Unit]("copy scala.js linker outputs to another location")\n  Seq(\n    copyJSOutput := {\n      println(s"Copying artifact ${scalaJSLinkedFile.in(Compile).value.path} to [${odir}]")\n      val src = file(scalaJSLinkedFile.in(Compile).value.path)\n      IO.copy(Seq(\n        (src, file(odir) / src.name),\n        (file(src.getCanonicalPath() + ".map"), file(odir) / (src.name + ".map"))\n      ), CopyOptions(true, true, true))\n    },\n    fastOptJS / copyJSOutput := (copyJSOutput triggeredBy fastOptJS.in(Compile)).value,\n    fullOptJS / copyJSOutput := (copyJSOutput triggeredBy fullOptJS.in(Compile)).value\n  )\n}\n\n// project def\nlazy val yourproject = project.in(...)\n  .settings(copyTask("../../somewhere"))\n')),Object(a.b)("p",null,"Or as a plugin:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-scala"}),'package ttg\npackage scalajs\n\nimport sbt._\nimport Keys._\nimport org.scalajs.sbtplugin.ScalaJSPlugin\nimport org.scalajs.sbtplugin.ScalaJSPlugin.autoImport._\n\n/**\n * Copy JS linker artifacts to another location. Add to your project to enable.\n */\nobject CopyJSPlugin extends AutoPlugin {\n  override def requires = ScalaJSPlugin\n\n  final object autoImport {\n    val copyTarget = SettingKey[String]("copyTarget", "scala.js linker artifact copy target directory")\n    val copyJS = TaskKey[Unit]("copyJS", "Copy scala.js linker artifacts to another location after linking.")\n  }\n  import autoImport._\n\n  override lazy val projectSettings = Seq(\n    copyJS := copyJSTask.value,\n    fastOptJS / copyJS := (copyJS triggeredBy fastOptJS.in(Compile)).value,\n    fullOptJS / copyJS := (copyJS triggeredBy fullOptJS.in(Compile)).value\n  )\n  //define inline via `copyJSTask := {` or separately like this\n  private def copyJSTask = Def.task {\n      val odir = copyTarget.value\n      println(s"Copying artifact ${scalaJSLinkedFile.in(Compile).value.path} to [${odir}]")\n      val src = file(scalaJSLinkedFile.in(Compile).value.path)\n      IO.copy(Seq(\n        (src, file(odir) / src.name),\n        (file(src.getCanonicalPath() + ".map"), file(odir) / (src.name + ".map"))\n      ), CopyOptions(true, true, true))\n    }\n}\n')),Object(a.b)("p",null,"Managing task running in sbt is covered in the\n",Object(a.b)("a",r({parentName:"p"},{href:"https://www.scala-sbt.org/release/docs/Tasks.html"}),"manual")," as there are a few\ndifferent ways to set the above copy operation up some of which are more simple\nthen defining a task. A really great blog on sbt tasks is\n",Object(a.b)("a",r({parentName:"p"},{href:"https://binx.io/blog/2018/12/08/the-scala-build-tool/"}),"here"),", you should read\nit just to be smarter about sbt."),Object(a.b)("p",null,"Here's a ",Object(a.b)("a",r({parentName:"p"},{href:"https://stackoverflow.com/questions/29371654/scala-js-compilation-destination/29375359#29375359"}),"stackoverflow")," article on the same topic."),Object(a.b)("h2",null,Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"calling-appregistryregistercomponent-in-scalajs"})),Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#calling-appregistryregistercomponent-in-scalajs"}),"#"),"Calling AppRegistry.registerComponent in scala.js"),Object(a.b)("p",null,"If your index.js file imports a function that performs the registration you need\nto write the registration function in scala first:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-scala"}),'@JSExportTopLevel("Main")\nobject Main {\n  @JSExport("main")\n  def maian(): Unit = {\n    AppRegistry.registerComponent("HelloWorld", () => App.JS)\n  }\n}\n')),Object(a.b)("p",null,"Regardless of whether you call ",Object(a.b)("inlineCode",{parentName:"p"},"registerComponent")," in scala or JS, you need to\ncreate the application component. That's easy. Don't forget to \"wrap\" it for JS\nuse. "),Object(a.b)("p",null,"In the code below, the component itself is exported so you can call\n",Object(a.b)("inlineCode",{parentName:"p"},"registerComponent")," in index.js. If you call ",Object(a.b)("inlineCode",{parentName:"p"},"registerComponent")," in scala as\nshow above, you do not need to export the anything related to the component but\nit still need to be wrapped."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-scala"}),'@JSExportTopLevel("App")\nobject App {\n  val Name = "App"\n  val c = statelessComponent(Name)\n  import c.ops._\n  \n  def apply() = render { self =>\n    View()(\n        Text()("This is some text.")\n    )\n  }\n  \n  @JSExport("JS")\n  val JS = c.wrapScalaForJs[js.Object](_ => App())\n}\n')),Object(a.b)("p",null,"The top level is usually a stateless component as it is called by the\nreact-native framework and does not take any arguments."),Object(a.b)("p",null,"If you have your exports setup using either approach, your index.js should\ninclude the scala.js output:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-javascript"}),'// index.js\n// Adjust for your output or use the copy method described above.\n// We assume you used the "copy to a well know location" below.\n\n// Scala.js runs registerComponent inside Main.\nimport { Main } from "./Scala.js"\n\n// JS calls registerComponent inside index.js.\nimport { App } from "./Scala.js"\n\n// Let Main run...\nMain.main()\n// or let javascript run...\nAppRegistry.registerComponent(appName, () => App.JS)\n')),Object(a.b)("p",null,"If you want to switch on the build type in javascript and skip the sbt\nconfiguration above, use an ES6 feature with dynamic imports (make sure its\nenabled in your environment if you need to):"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{}),'if(process.env.NODE_ENV === "production") then { \nconst Main = import("./target/scala-2.12/app-opt.js")\n}\nelse {\nconst Main = import("./target/scala-2.12/app-fastopt.js")\n}\n')),Object(a.b)("p",null,'If you don\'t have ES6 support you could use the legacy "require(...)"  which\nshould be supported for some time to come with most bundlers. The default\nreact-native metro should allow the dynamic import using ',Object(a.b)("inlineCode",{parentName:"p"},"import"),". If you use\nthis approach, make sure any imported resources such as images are available\nbased on a path relative to the js file as your scala or js imports inside of\napp-opt.js/app-fastopt.js will now be relative to the target/scala-2.12\ndirectory."),Object(a.b)("h2",null,Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"build"})),Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#build"}),"#"),"Build"),Object(a.b)("p",null,"Run sbt as you normally would and during dev and use ",Object(a.b)("inlineCode",{parentName:"p"},"~fastOptJS")," if you used\nthe triggered approach to perform the scala.js output copy. That allows you to\nrecompile as needed. react native uses its own JS packager, called metro, that\nrestructures your JS similar to webpack."),Object(a.b)("p",null,"metro is not as feature-rich as webpack. When you run ",Object(a.b)("inlineCode",{parentName:"p"},"react-native run-android"),"\nit first runs gradle to build the java part of the project and it starts up a JS\nserver similar to the way that webpack-dev-server works. It is suppose to detect\nchanges in js files and do a hot reload. You may need to turn on hot reloading\nusing Ctrl+M (linux/windows hosted emulators)."),Object(a.b)("h2",null,Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"helpers"})),Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#helpers"}),"#"),"Helpers"),Object(a.b)("p",null,"While you should install android studio because you will probably need to write\nsome interop at some point, you can start the emulator without starting android\nstudio:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-sh"}),"# List emulator devices.\n$ emulator -list-devs\n\n# Start an emulator I defined in android studio.\n$ emulator -avd Pixel_2_XL_API_28 -no-boot-anim\n")),Object(a.b)("p",null,"You will want to add:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-sh"}),"export ANDROID_HOME=$HOME/Android/Sdk\nexport PATH=$PATH:$ANDROID_HOME/emulator\nexport PATH=$PATH:$ANDROID_HOME/tools\nexport PATH=$PATH:$ANDROID_HOME/tools/bin\nexport PATH=$PATH:$ANDROID_HOME/platform-tools\n")),Object(a.b)("p",null,"to a shell script you can import into your current terminal."),Object(a.b)("h2",null,Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"other-libraries"})),Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#other-libraries"}),"#"),"Other Libraries"),Object(a.b)("p",null,"There are some ports of common libraries, all WIP and some have no code yet :-):"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"react-navigation (working)"),Object(a.b)("li",{parentName:"ul"},"sideswipe (working)"),Object(a.b)("li",{parentName:"ul"},"nativebase (no code yet)"),Object(a.b)("li",{parentName:"ul"},"react-native-elements (no code yet)")),Object(a.b)("p",null,"Creating facades is easy. It only took 3 hours to create the entire facade for\nreact-native from scratch when I did not even know react-native. I just look at\nthe typescript definitions and develop a scala.js friendly API from there. I\nbelieve that a good combination is to use scala.js and typescript together."),Object(a.b)("h2",null,Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"resources"})),Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#resources"}),"#"),"Resources"),Object(a.b)("p",null,"Widget/other libraries:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://docs.nativebase.io"}),"nativebase")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://react-native-training.github.io/react-native-elements"}),"react-native-elements")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",r({parentName:"li"},{href:"https://github.com/oblador/react-native-vector-icons"}),"icons"))),Object(a.b)("h2",null,Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"result"})),Object(a.b)("a",r({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#result"}),"#"),"Result"),Object(a.b)("p",null,"Here's a simple screen using Text and Button."),Object(a.b)("p",null,Object(a.b)("img",r({parentName:"p"},{src:"./android-screen.png",alt:"Android screenshot"})),'{:width="300px"}'),Object(a.b)("p",null,"app.scala"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-scala"}),'import scala.scalajs.js\nimport js.annotation._\nimport js.JSConverters._\nimport concurrent._\nimport concurrent.ExecutionContext.Implicits.global\n\nimport ttg.react\nimport react._\nimport elements._\nimport react.implicits._\nimport ttg.react.native\nimport native._\nimport native.styling._\n\nobject App {\n\n  val instructions = Platform.select(choices[String](\n    "ios" ->\n      "Press Cmd+R to reload,\\nCmd+D or shake for dev menu",\n    "android" ->\n      ("Double tap R (that\'s twice!) on your keyboard to reload,\\n" +\n      "Shake or press menu button for dev menu (or Ctrl-M)"),\n  ))\n\n  def handleClick(url: String): Unit =\n    for {\n      supported <- Linking.canOpenURL(url).toFuture\n      _ <- if (supported) Linking.openURL(url).toFuture\n      else Future{println("Unable to open URI: " + url)}\n    } yield ()\n\n  val url = "https://aappddeevv.github.io/scalajs-react/docs/native.html"\n\n  val Name = "App"\n  val c = statelessComponent(Name)\n  import c.ops._\n\n  def apply() = render { self =>\n    View(new View.Props {\n      style = styles.container\n    })(\n      Text(new Text.Props {\n        style = styles.welcome\n      })(s"Welcome to React Native with Scala.js! (${Platform.OS})"),\n      Text(new Text.Props {\n        style = styles.instructions\n      })("To get started, edit main.scala"),\n      Text(new Text.Props {\n        style = styles.instructions\n      })(instructions),\n      Text(new Text.Props {\n      })(\n        "React native info & libs:\\nhttps://facebook.github.io/react-native\\nhttps://nativebase.io\\nhttps://react-native-training.github.io"\n      ),\n      Button(new Button.Props {\n        val title = "Learn More on Github"\n        val onPress = _ => handleClick(url)\n      })()\n    )\n  }\n\n  @JSExport("JS")\n  val JS = c.wrapScalaForJs[js.Object](_ => App())//_ => apply())\n\n  trait Styles extends StyleSet {\n    val container: ViewStyle\n    val welcome: TextStyle\n    val instructions: TextStyle \n  }\n\n  val styles = StyleSheet.create(\n   new Styles {\n     val container = new ViewStyle {\n      flex = 1\n      justifyContent = JustifyContent.center\n      alignItems = FlexAlignType.center\n      backgroundColor = "#F5FCFF"\n    }\n    val welcome = new TextStyle {\n      fontSize = 20\n      textAlign = TextAlign.center\n      margin = 10\n    }\n    val instructions = new TextStyle {\n      textAlign = TextAlign.center\n      color = "#333333"\n      marginBottom = 5\n    }}\n  )\n}\n')),Object(a.b)("p",null,"main.scala:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-scala"}),'import scala.scalajs.js\nimport js.annotation._\n\nimport ttg.react.native\nimport native._\n\n@JSExportTopLevel("Main")\nobject Main {\n  @JSExport("main")\n  def main(): Unit = {\n    AppRegistry.registerComponent("HelloWorld", () => App.JS)\n  }\n}\n')),Object(a.b)("p",null,"index.js:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"import {AppRegistry} from 'react-native'\nimport {name as appName} from './app.json'\nimport { Main } from \"./Scala.js\"\n\nMain.main()\n")))}p.isMDXComponent=!0},89:function(e,t,n){"use strict";n.d(t,"a",function(){return l}),n.d(t,"b",function(){return u});var a=n(0),r=n.n(a),o=r.a.createContext({}),i=function(e){var t=r.a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},l=function(e){var t=i(e.components);return r.a.createElement(o.Provider,{value:t},e.children)},s="mdxType",c={inlineCode:"code",wrapper:function(e){return r.a.createElement(r.a.Fragment,{},e.children)}},p=function(e){var t=e.components,n=e.mdxType,a=e.originalType,o=e.parentName,l=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}(e,["components","mdxType","originalType","parentName"]),s=i(t);return r.a.createElement(s[o+"."+n]||s[n]||c[n]||a,t?Object.assign({},l,{components:t}):l)};function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[s]="string"==typeof e?e:a,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);