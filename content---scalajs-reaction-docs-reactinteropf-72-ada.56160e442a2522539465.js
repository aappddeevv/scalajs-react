(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{67:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return s}),n.d(t,"rightToc",function(){return i}),n.d(t,"default",function(){return p});n(0);var a=n(89);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s={layout:"docs",title:"React Interop"},i=[{value:"Ref and Key",id:"ref-and-key",children:[]},{value:"Suspense",id:"suspense",children:[]}],c={rightToc:i},l="wrapper";function p(e){var t=e.components,n=r(e,["components"]);return Object(a.b)(l,o({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",null,Object(a.b)("a",o({parentName:"h1"},{"aria-hidden":!0,className:"anchor",id:"react-interop"})),Object(a.b)("a",o({parentName:"h1"},{"aria-hidden":!0,className:"hash-link",href:"#react-interop"}),"#"),"React Interop"),Object(a.b)("p",null,"The interop layer is structured much like ReasonReact so you can read those\ndocuments to understand how scalaj-react is structured. It's pretty much the\nsame thing."),Object(a.b)("p",null,"A few differences:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Instead of a record structure for scala side component, we use a javascript\nobject."),Object(a.b)("li",{parentName:"ul"},"initialState takes a ",Object(a.b)("inlineCode",{parentName:"li"},"Self")," so you have access to callback handlders in case\nany object you need to create for your state requires them. You can use the\nother methods to get around this or even use mutable state (and change it\ndirectly) in another API callback like didMount but this makes it easier."),Object(a.b)("li",{parentName:"ul"},"A generator function is provided in the reducer to create the state update\nmessages. This is a better approach than having to create your own objects for\nthe state update directive."),Object(a.b)("li",{parentName:"ul"},"The methods have been changed so that you are ",Object(a.b)("em",{parentName:"li"},"only"),' provided a "self"\nfunction parameter that make sense for that method. You cannot, for example,\nsee a "state" object in "self" if you are using a stateless component.'),Object(a.b)("li",{parentName:"ul"},'You are forced to defined the retained props or initial state in the "new\nmethods" call if they are required. If you have a stateful comonent, you must\ndefine them. Mandatory fields on "methods" are indicated by a val as show below.')),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-scala"}),'case class MyState(...)\nval c = reducerComponent[MyState]("component")\nimport c.ops._\n\ndef make(...) = c.copy(new methods {\n    val initialState = MyState()\n    val render = self => { ... }\n})\n')),Object(a.b)("h2",null,Object(a.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"ref-and-key"})),Object(a.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#ref-and-key"}),"#"),"Ref and Key"),Object(a.b)("p",null,"Ref and key are special properties used by react to assist in accessing the\ncomponent instance or managing arrays of values. These properties are ripped out\nof props and processed special by reactjs."),Object(a.b)("p",null,"Model ref and key explicitly in your SFC props."),Object(a.b)("h2",null,Object(a.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"suspense"})),Object(a.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#suspense"}),"#"),"Suspense"),Object(a.b)("p",null,"Suspense allows you to delay rendering until a js.Promise completes. In the\nreact rendering engine, suspended components continue to display their content\nuntil the effect completion, with a possible fallback in case the effect\nfails. This allows you to continue to show user relevant content until the\nrendering completes. While you can do some of this today, without using\nsuspense, the user-experience is bit jerky. You throw the promise in the\nrendering function."),Object(a.b)("p",null,"There are a couple of complications."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"You cannot throw a raw promise in scala.js. It's always wrapped up before it\nhits the js side."),Object(a.b)("li",{parentName:"ul"},"You cannot call ",Object(a.b)("inlineCode",{parentName:"li"},"import")," as a function as its really a keyword in javascript\nnow.")),Object(a.b)("p",null,"To use Suspense and React.lazy, you'll need to do one of a few different\napproaches:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Create a .ts/.js file that exports a component that is created using\n",Object(a.b)("inlineCode",{parentName:"li"},"React.lazy"),". The component needs to be non-scalajs component since scalajs\nbundles ",Object(a.b)("em",{parentName:"li"},"everything")," together. Import that component as a ReactLazyComponent\nand then call ",Object(a.b)("inlineCode",{parentName:"li"},"wrapJsForScala")," to create a scala component."),Object(a.b)("li",{parentName:"ul"},"Create a .ts/.js file and include only exports of the form ",Object(a.b)("inlineCode",{parentName:"li"},'() =>\nimport("amodule")'),". The import type is DynamicImportThunk and that can used as\nan argument to scala's ",Object(a.b)("inlineCode",{parentName:"li"},"React.lazy"),". You need to define it as a function so\nthe ts/js Promise is not started immediately. Since you are created deferred\ncomputations, you can define as many of these as you want in a single file and\nimport them all at once."),Object(a.b)("li",{parentName:"ul"},"Externalize the entire Suspense and React.lazy machine and just import a\ncomponent from a js/ts module in its entirety.")),Object(a.b)("p",null,"In react 16.8, only lazy loading is supported but any component that throws a\njavascript Promise can be used which is how React.lazy and dynamic imports\nwork. Creating a dynamic import creates as javascript Promise that resolves to\nthe module content."),Object(a.b)("p",null,"Since scala cannot throw a raw javascript Promise, you can create a lazy\ncomponent by throwing inside a ts/js defined Component. The demo shows how this\ncan be done in ts/js. This also means that if you use Suspense, the chain of\nparent components must not be a Component object since a ",Object(a.b)("inlineCode",{parentName:"p"},"didCatch")," proxy is\ninstalled and once that handler is used, you cannot rethrow easily into the js\nworld again. Hence, you any component that implements the ",Object(a.b)("inlineCode",{parentName:"p"},"throwit")," trick below\nmust check for a Promise object and throw it in the javascript world and so\non. Since this is a bit awkward, it is suggested that your Promise throwing\ncomponent be defined using ",Object(a.b)("inlineCode",{parentName:"p"},"SFC"),", which is a pure javscript function component,\nnot a Component (in this facade), and that it be a direct child of a Suspense\ncomponent."),Object(a.b)("p",null,"As a trick, you can define an scala import module that imports a single function\nthat throws an object for you."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"export default throwit(e) { throw e }\n")),Object(a.b)("p",null,"then import it"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-scala"}),'@js.native\n@JSImport("throwit", JSImport.Default)\nobject throwit { \n   def apply(t: js.Any): Unit = js.native\n}\n')),Object(a.b)("p",null,"Then throw it in your function, such as a SFC"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-scala"}),'val sfc = SFC[js.Object]{ _ =>\n  val x = throwit(..code that creates a promise...)\n  div("My nodes to display")\n}\n')),Object(a.b)("p",null,"But the trick is to have a js.Promise that is smart enough to resolve once the\ncontent has been loaded. This typically uses a backing store of some sort\ne.g. cache. If you naviavely try this and its a new promise that never completes\n(resolve or fail), you may hang the UI at some point since the promise never\ncompletes."),Object(a.b)("p",null,"It's not clear how useful this all is although the lazy loading use case is\ninteresting in a mixed project."),Object(a.b)("p",null,"Because of the Suspense feature, ",Object(a.b)("inlineCode",{parentName:"p"},"didCatch")," has been removed from scala\nComponents until the interaction between them is better understood."),Object(a.b)("p",null,"We suggest you look at other libraries that may be easier to use such as\n",Object(a.b)("a",o({parentName:"p"},{href:"https://www.smooth-code.com/open-source/loadable-components/"}),"loadable\ncomponents"),"."))}p.isMDXComponent=!0},89:function(e,t,n){"use strict";n.d(t,"a",function(){return i}),n.d(t,"b",function(){return u});var a=n(0),o=n.n(a),r=o.a.createContext({}),s=function(e){var t=o.a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},i=function(e){var t=s(e.components);return o.a.createElement(r.Provider,{value:t},e.children)},c="mdxType",l={inlineCode:"code",wrapper:function(e){return o.a.createElement(o.a.Fragment,{},e.children)}},p=function(e){var t=e.components,n=e.mdxType,a=e.originalType,r=e.parentName,i=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}(e,["components","mdxType","originalType","parentName"]),c=s(t);return o.a.createElement(c[r+"."+n]||c[n]||l[n]||a,t?Object.assign({},i,{components:t}):i)};function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[c]="string"==typeof e?e:a,s[1]=i;for(var u=2;u<r;u++)s[u]=n[u];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);