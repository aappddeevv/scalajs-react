(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{124:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(1),l=n(6),i=(n(0),n(143)),o={id:"data_interop",title:"Data Interop"},r={id:"misc/data_interop",title:"Data Interop",description:"Since there is an emphasis on interop with javascript reactjs components, you",source:"@site/docs/misc/datainterop.md",permalink:"/scalajs-reaction/docs/misc/data_interop",editUrl:"https://github.com/aappddeevv/scalar2020online/edit/master/presentation/docs/misc/datainterop.md",sidebar:"docs",previous:{title:"Bundling",permalink:"/scalajs-reaction/docs/misc/bundling"}},s=[{value:"JS -&gt; Scala",id:"js---scala",children:[]},{value:"Scala -&gt; JS",id:"scala---js",children:[]},{value:"pimps",id:"pimps",children:[]},{value:"Don&#39;t Forget About a Structural Check",id:"dont-forget-about-a-structural-check",children:[]},{value:"TL;DR",id:"tldr",children:[]}],c={rightToc:s};function u(e){var t=e.components,n=Object(l.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Since there is an emphasis on interop with javascript reactjs components, you\nneed to also interop with javascript data. Scala.js offers ",Object(i.b)("inlineCode",{parentName:"p"},"js.UndefOr"),' to\ninterop with fields in data structures that do not exist. Of course, in\njavascript a value can be undefined or null and sometimes they mean the same\nthing and sometimes not to an API. Sometimes APIs are not precise and either\nundefined or null means "not present."'),Object(i.b)("p",null,"scala itself offers the ability to assign ",Object(i.b)("inlineCode",{parentName:"p"},"null"),"\n(subclass of ",Object(i.b)("inlineCode",{parentName:"p"},"Null"),') to most values e.g. a String can be a value ("george"),\nempty ("") or null.'),Object(i.b)("p",null,"The key message is that even with a typescript description to guide you,\nyou need to be defensive since null and undefined are often used interchangeably\nin javascript since its so easy to do ",Object(i.b)("inlineCode",{parentName:"p"},"a ? ...")," or ",Object(i.b)("inlineCode",{parentName:"p"},"!!a")," ior ",Object(i.b)("inlineCode",{parentName:"p"},"if(a) ..."),' and if a is null or undefined,\nit will evaluate to "false".'),Object(i.b)("h2",{id:"js---scala"},"JS -> Scala"),Object(i.b)("p",null,"Given that we also use native and non-native JS traits to describe the shape of\ndata, we may wonder how to handle data from web APIs, for example in the\nstructure:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"export interface Foo { \n    field1?: string\n    field2?: string | null\n}\n")),Object(i.b)("p",null,"field1 can be undefined or a string and field2 can be a string value, undefined\nor null. Depending on the nature of the data source, you may encounter alot of\nfield1 or field2 on some combination of that. For example, field1 could\nrepresent a value that is non-nullable in the source database but may not have\nbeen requested in a fetch and may not be present. field2 could represent a\nnullable field in the source database that was not requested or was requested\nand was null."),Object(i.b)("p",null,"The question is how to best model these in scala so that we do not have to write\nan object conversions for each data structure. "),Object(i.b)("p",null,'If you know the data is either there or not there, then UndefOr is fine recognizing\nthat "null" is a valid value:'),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"trait Foo extends js.Object {\n  var field: js.UndefOr[String] // var so mutable, use val for immutable\n}\n")),Object(i.b)("p",null,"However, if field can be null, undefined or a value what should we use? Consider:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"trait Foo extends js.Object {\n  var field1: js.UndefOr[String]\n}\n")),Object(i.b)("p",null,"Here, the value may not be present but it could be null, which is ",Object(i.b)("em",{parentName:"p"},"different"),"\nthen not being present. We could test:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"aFoo.field == null\n// or\naFoo.orNull == null\n")),Object(i.b)("p",null,"which returns true or false depending on whether the value is null. ",Object(i.b)("inlineCode",{parentName:"p"},"UndefOr"),"\nhas its own pimp which returns null if UndefOr is undefined, but not if its\nnull:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val x: jsUndefOr[String] = ...\nval test: String = x.orNull // test could be a string or null\n")),Object(i.b)("p",null,"What we generally need when obtaining data from javascript is something that\nrecognizes the idioms that if a value is undefined or null, then its \"false\" or\nNone, not just if its' undefined. UndefOr's ",Object(i.b)("inlineCode",{parentName:"p"},"isEmpty")," function just checks if\nits undefined, so its not quite right for our needs. What we need is to get to a\nscala Option (or something like that) when the value is null ",Object(i.b)("em",{parentName:"p"},"or")," undefined."),Object(i.b)("p",null,"scalajs-reaction provides a pimp:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"final case class JsUndefOrOps[A](a: UndefOr[A]) {\n  def isNull  = a == null\n  def isEmpty = isNull || !a.isDefined\n}\n")),Object(i.b)("p",null,"which can be implicitly used by importing the syntax so you can test:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val aBoolean = aFoo.field1.isNull // is it just null?\nval aBoolean2 = afoo.field1.isEmpty // is it null or undefined\n")),Object(i.b)("p",null,"So we can test for null fairly easily given the ",Object(i.b)("inlineCode",{parentName:"p"},"UndefOr")," type definition. But\nwe want to manipulate these things with some more functional syntax. For\nexample, we would like an Option-based variant that is None if ",Object(i.b)("inlineCode",{parentName:"p"},"isEmpty==true"),"\nand the value otherwise. Using ",Object(i.b)("inlineCode",{parentName:"p"},"UndefOr.toOption"),' actually may wrap a "null"\nvalue and produce a ',Object(i.b)("inlineCode",{parentName:"p"},"Some(null)")," instead of None. So clearly, just using\n",Object(i.b)("inlineCode",{parentName:"p"},".toOption")," is not a good answer. So at the expense of a little boolean check,\nperhaps we could do something more convenient. "),Object(i.b)("p",null,"Let's state what we want, an\nOption that reflects both UndefOr and possible underlying null value:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"final case class JsUndefOrOps[A](a: UndefOr[A]) {\n  @inline def toNonNullOption = if(a == null || a.isEmpty) None else a.toOption\n}\n")),Object(i.b)("p",null,'So now we can safely convert a UndefOr to an Option and have it be "null" if it\nis null or undefined and a Some with a non-null value otherwise. The cost you\npay is a small conversion charge. So in general, it\'s ok to model your data us\nUndefOr:'),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"})," val x: Option[String] = aFoo.field1.toNonNullOption\n")),Object(i.b)("p",null,"Also, if you need to set data to null and the trait defines it as an UndefOr,\njust set it directly to null, just before you dispatch it javascript code:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"  aFoo.field1 = null\n")),Object(i.b)("p",null,"You should note that just declaring the attribute as a type:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"trait Foo extends js.Object {\n  var field1: String\n}\n")),Object(i.b)("p",null,"does not communicate that it can be null but we know scala allows this. "),Object(i.b)("p",null,"Perhaps we should use\n",Object(i.b)("inlineCode",{parentName:"p"},"var field1: String|Null"),". There's nothing wrong with that except scala already\ndefines that String to be potentially null so why go through the hassle?\nSee below why we might want to be that explicit."),Object(i.b)("p",null,"If you see a trait with just a plain String and you want an Option just wrap it\njust like in, ",Object(i.b)("inlineCode",{parentName:"p"},"Option(field1)")," since Option translates null to None in plain\nscala to begin with."),Object(i.b)("h2",{id:"scala---js"},"Scala -> JS"),Object(i.b)("p",null,"The story is a bit easier on the Scala -> JS connection. You generally need this\nwhen stuffing data into a data structured destined for the js side of the world."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Have (a: Option","[T]","): ",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"a.orUndefined")," yields an UndefOr which is the type that will probably be\nin most of your non-native JS traits"),Object(i.b)("li",{parentName:"ul"},"Use ",Object(i.b)("inlineCode",{parentName:"li"},"a.getOrElse(null)")," to obtain the value or null for some non-native JS traits"))),Object(i.b)("li",{parentName:"ul"},"Have (a: A): ",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Wrap it ala ",Object(i.b)("inlineCode",{parentName:"li"},"js.defined(a)")," to get an ",Object(i.b)("inlineCode",{parentName:"li"},"UndefOr[A]")," to satisfy your trait's\ntype (if you used the approach above)."),Object(i.b)("li",{parentName:"ul"},"If the value could be null, you can wrap it in Option(a) then convert it as\ndescribed above to obtain an UndefOr. However if your JS target is ",Object(i.b)("inlineCode",{parentName:"li"},"A|null"),"\nthen there is nothing you need to do as scala and javascript both match the\ndesired semantics.")))),Object(i.b)("h2",{id:"pimps"},"pimps"),Object(i.b)("p",null,"Check out\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/aappddeevv/scalajs-react/blob/master/scalajs-react-core/src/main/scala/syntax.scala"}),"syntax.scala"),"\nfor many pimps that you can apply to UndefOr values to help with data\nmanipulation on the scala side. There's alot there and its easy to forget them\nunless they are in a cheatsheet."),Object(i.b)("h2",{id:"dont-forget-about-a-structural-check"},"Don't Forget About a Structural Check"),Object(i.b)("p",null,"There is a little known converter in scala.js. If you have two traits that are\nnot related but have overlapping fields, you may need to cast one to the other\nwhat is essentially a structural cast, check out ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.scala-js.org/api/scalajs-library/latest/#scala.scalajs.js.package@use%5BA%5D(x:A):scala.scalajs.js.Using%5BA%5D"}),"funky structural\ncast-kindof"),". It uses ",Object(i.b)("inlineCode",{parentName:"p"},"use"),"."),Object(i.b)("h2",{id:"tldr"},"TL;DR"),Object(i.b)("p",null,"Let's assume that typescript is not properly annotated and some undefineds and nulls get mixed up. "),Object(i.b)("p",null,"If your typescript says:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"field1?: string\n")),Object(i.b)("p",null,"use this type of declaration in your trait:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"var/val field1: js.UndefOr[String] = js.undefined\n")),Object(i.b)("p",null,"and use ",Object(i.b)("inlineCode",{parentName:"p"},"field1 = null")," if you want to set it to null or extract using\n",Object(i.b)("inlineCode",{parentName:"p"},"field1.toNonNullOption")," to extract an option more safely than just ",Object(i.b)("inlineCode",{parentName:"p"},"toOption"),"\nsince the value could secretly be a null."),Object(i.b)("p",null,"If typescript says:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"field1?: string|null\n")),Object(i.b)("p",null,"You can be more specific in scala.js than just saying its String as in scala\na value like that can be null. However, we can be more procise:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"val field1: js.UndefOr[String|Null]\n")),Object(i.b)("p",null,"You have a choice of how explicit you want to make this. "),Object(i.b)("p",null,"If you use ",Object(i.b)("inlineCode",{parentName:"p"},"String|Null")," you can use an implicit ",Object(i.b)("inlineCode",{parentName:"p"},"absorbNull")," to change this to a ",Object(i.b)("inlineCode",{parentName:"p"},"js.UndefOr[String]"),"\nlike so ",Object(i.b)("inlineCode",{parentName:"p"},"field1.absorbNull")," or ",Object(i.b)("inlineCode",{parentName:"p"},"field1.absorbNullKeepTruthy"),".\nor you can map into it and flatten the ",Object(i.b)("inlineCode",{parentName:"p"},"String|Null")," via a ",Object(i.b)("inlineCode",{parentName:"p"},"field1.flatMap(_.toUndefOr)"),". If\nthe field was just ",Object(i.b)("inlineCode",{parentName:"p"},"val field1: String|Null")," then there is an implicit conversion\nfrom ",Object(i.b)("inlineCode",{parentName:"p"},"String|Null")," to ",Object(i.b)("inlineCode",{parentName:"p"},"js.UndefOr[]")," via ",Object(i.b)("inlineCode",{parentName:"p"},"aStringNull.toUndefOr")," which when flatMapped,\ngives you a ",Object(i.b)("inlineCode",{parentName:"p"},"js.UndefOr[String]"),". Again, you have a choice on how you want to do this."),Object(i.b)("p",null,"Check out the syntax extensions to get a feel for a wide range of how to treat this\ncommon javascript pattern. There are some specialized conversions for ",Object(i.b)("inlineCode",{parentName:"p"},"js.UndefOr[String|Null]"),"\nand ",Object(i.b)("inlineCode",{parentName:"p"},"js.UndefOr[Boolean|Null]"),"."),Object(i.b)("p",null,"If typescript says:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"field1: string|null\n")),Object(i.b)("p",null,"and you use "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"var/val field1: String|Null\n")),Object(i.b)("p",null,"you can set it null if you need to: ",Object(i.b)("inlineCode",{parentName:"p"},"field1 = null"),"."),Object(i.b)("p",null,"Let's hope the typescript interface descriptions are correct!"),Object(i.b)("p",null,"Again, please see the syntax extensions package a multitude of ways to manage these nits."))}u.isMDXComponent=!0},143:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return f}));var a=n(0),l=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var c=l.a.createContext({}),u=function(e){var t=l.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r({},t,{},e)),n},p=function(e){var t=u(e.components);return l.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),d=a,f=p["".concat(o,".").concat(d)]||p[d]||b[d]||i;return n?l.a.createElement(f,r({ref:t},c,{components:n})):l.a.createElement(f,r({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:a,o[1]=r;for(var c=2;c<i;c++)o[c]=n[c];return l.a.createElement.apply(null,o)}return l.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);