(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{76:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return l}),t.d(n,"rightToc",function(){return o}),t.d(n,"default",function(){return p});t(0);var a=t(92);function s(){return(s=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function r(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l={id:"styling",title:"Styling"},o=[{value:"Inline Styles",id:"inline-styles",children:[]},{value:"Webpack CSS Processing (external CSS) and js.Dynamic",id:"webpack-css-processing-external-css-and-jsdynamic",children:[]},{value:"CSS in JS/Scala",id:"css-in-jsscala",children:[]},{value:"@uifabric merge-styles",id:"uifabric-merge-styles",children:[]}],i={rightToc:o},c="wrapper";function p(e){var n=e.components,t=r(e,["components"]);return Object(a.b)(c,s({},i,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Styling is a topic with many wide-ranging solutions. I suggest you check out the\n",Object(a.b)("a",s({parentName:"p"},{href:"http://appddeevvmeanderings.blogspot.com/2017/08/web-app-styling-interlude-how-to.html"}),"blog"),"\non how to think about the styling approach that will work for you."),Object(a.b)("p",null,"Generally, doing styling in the language, e.g. js or scala, allows you to\ncustomize the styling while still retaining most levels of performance. Heavy\nand complex styling will always require a complex process. Check out\n",Object(a.b)("a",s({parentName:"p"},{href:"https://github.com/japgolly/scalacss"}),"ScalaCSS")," or udash's version about scala\nspecific CSS-in-Scala solutions."),Object(a.b)("p",null,"Recommendation: Use a js-based library like uifabric's\n",Object(a.b)("a",s({parentName:"p"},{href:"https://github.com/OfficeDev/office-ui-fabric-react/tree/master/packages/merge-styles"}),"merge-styles"),"\nor ",Object(a.b)("a",s({parentName:"p"},{href:"https://github.com/threepointone/glamor"}),"glamor (javascript)"),"."),Object(a.b)("h2",null,Object(a.b)("a",s({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"inline-styles"})),Object(a.b)("a",s({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#inline-styles"}),"#"),"Inline Styles"),Object(a.b)("p",null,"If you are looking for something that mildly helps you detect errors, such as bad styling attribute names, you can use vdom's style for inline styles as described in that section. In addition, it also provides inline styles via"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-scala"}),'import ttg.react.vdom.style._\nval style1 = new StyleAttr { display: "flex" }\nval style2 = new StyleAttr { flexDirection: "column" }\n\n// style2 takes precedence\nval flexVertical = merge(style1, style2)\n')),Object(a.b)("h2",null,Object(a.b)("a",s({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"webpack-css-processing-external-css-and-jsdynamic"})),Object(a.b)("a",s({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#webpack-css-processing-external-css-and-jsdynamic"}),"#"),"Webpack CSS Processing (external CSS) and js.Dynamic"),Object(a.b)("p",null,"Assuming you are using webpack or CSS processing, CSS import produces a\njs.Object whose keys are style names (sometimes mangled) and whose values are\nstyles. css-loader combined with style-loader then translates that into a\nstylesheet that is dynamically inserted into the DOM."),Object(a.b)("p",null,'To use that method, ensure webpack has an alias to the location of your CSS\nfiles. I tend to put my CSS files right next to the component and hence my\nwebpack alias "Styles", for example, points to my source directory. Then you can\nuse:'),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-scala"}),'@js.native\n@JSImport("Styles/somecomponentdir/component.css", JSImport.Namespace)\nobject cstylesns extends js.Object\n\n// put all imported styles into the same object\nobject styles {\n  val cstyles = cstylesns.asInstanceOf[js.Dynamic] // to make it easy, but not type-safe\n}\n\n// then import them all or ala carte\nimport styles._\n\n// use them\n// cstyles.root or cystyles.input\n')),Object(a.b)("p",null,"You could use something other than js.Dynamic but that involves potentially alot\nof typing."),Object(a.b)("h2",null,Object(a.b)("a",s({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"css-in-jsscala"})),Object(a.b)("a",s({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#css-in-jsscala"}),"#"),"CSS in JS/Scala"),Object(a.b)("p",null,"This is becoming a much more preferred approach when the processing power of\nyour client allows to do this. While pre-processed and smartly bundled CSS can\ngive you load flexbility and performance benefits, the flexibility and sometimes\nnegligible impact on performance that current solutions provide make this more\npopular."),Object(a.b)("p",null,"There are some pure scala solutions available such as\n",Object(a.b)("a",s({parentName:"p"},{href:"https://github.com/japgolly/scalacss"}),"ScalaCSS")," as well as\n",Object(a.b)("a",s({parentName:"p"},{href:"https://udash.io/"}),"udash")," both of have CSS in Scala solutions, you have many\nchoices include ",Object(a.b)("a",s({parentName:"p"},{href:"https://github.com/threepointone/glamor"}),"glamor (javascript)"),"\nand something very similar such as fabric's styling\n(",Object(a.b)("a",s({parentName:"p"},{href:"https://github.com/OfficeDev/office-ui-fabric-react/tree/master/packages/merge-styles"}),"merge-styles"),"). fabric's\nmerge-styles claims to be slightly smaller on the payload than glamor."),Object(a.b)("p",null,"You can use this style of style processing but if you do, you want to consider\ndefining your styles in JS and importing them as JS data. Then use a facade over\na CSS in JS library to add them once you have manipulated them as needed. You do\nnot gain type-safety with this approach but if you use typescript bindings in\ntypescript code, its probably good enough."),Object(a.b)("h2",null,Object(a.b)("a",s({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"uifabric-merge-styles"})),Object(a.b)("a",s({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#uifabric-merge-styles"}),"#"),"@uifabric merge-styles"),Object(a.b)("p",null,"@uifabric/merge-styles is an independent package from microsoft. You can\ndo css-in-js styles as follows:"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-scala"}),'// other imports for react and fabric ...\n\nimport merge_styles._\n\nobject MyComponent {\n\n  trait Props extends js.Object {\n    var rootClassName: js.UndefOr[String] = js.undefined\n    var styles: js.UndefOr[IStyleFunctionOrObject[StyleProps, Styles]] = js.undefined\n    val children: String => ReactNode\n  }\n\n  val Name = "MyComponent"\n  def apply(props: Props) = sfc(props)\n\n  val sfc = SFC1[Props] { props =>\n    React.useDebugValue(Name)\n    val cn = getClassNames(new StyleProps {\n      className = props.rootClassName\n    }, props.styles)\n\n    divWithClassname(\n      cn.root,\n      props.content(cn.content)\n    )\n  }\n\n  @js.native\n  trait ClassNames extends IClassNamesTag {\n    val root: String = js.native\n    val content: String = js.native\n  }\n\n  trait Styles extends IStyleSetTag {\n    var root: js.UndefOr[IStyle] = js.undefined\n    var content: js.UndefOr[IStyle] = js.undefined\n  }\n\n  trait StyleProps extends js.Object {\n    var className: js.UndefOr[String] = js.undefined\n  }\n\n  val getStyles = stylingFunction[StyleProps, Styles] { props =>\n    new Styles {\n      root = stylearray(\n        "app-MyComponent-root",\n        new IRawStyle {\n          display = "flex"\n          flexWrap = "nowrap"\n          alignItems = "stretch"\n          height = "calc(100% - 48px)"\n        },\n        props.className\n      )\n      content = stylearray("app-MyComponent-content", new IRawStyle {\n        flex = "1 1 auto"\n        overflowY = "auto"\n      })\n    }\n  }\n\n  val getClassNames: GetClassNamesFn[StyleProps, Styles, ClassNames] =\n    (props, styles) => mergeStyleSets(concatStyleSetsWithProps[StyleProps, ClassNames](props, getStyles, styles))\n}\n')))}p.isMDXComponent=!0},92:function(e,n,t){"use strict";t.d(n,"a",function(){return o}),t.d(n,"b",function(){return m});var a=t(0),s=t.n(a),r=s.a.createContext({}),l=function(e){var n=s.a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},o=function(e){var n=l(e.components);return s.a.createElement(r.Provider,{value:n},e.children)},i="mdxType",c={inlineCode:"code",wrapper:function(e){return s.a.createElement(s.a.Fragment,{},e.children)}},p=function(e){var n=e.components,t=e.mdxType,a=e.originalType,r=e.parentName,o=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),i=l(n);return s.a.createElement(i[r+"."+t]||i[t]||c[t]||a,n?Object.assign({},o,{components:n}):o)};function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,l=new Array(r);l[0]=p;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o[i]="string"==typeof e?e:a,l[1]=o;for(var m=2;m<r;m++)l[m]=t[m];return s.a.createElement.apply(null,l)}return s.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);