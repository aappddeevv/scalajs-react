(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{73:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return i}),t.d(n,"rightToc",function(){return c}),t.d(n,"default",function(){return u});t(0);var a=t(89);function o(){return(o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i={id:"routing",title:"Routing"},c=[{value:"Lowest Level",id:"lowest-level",children:[]},{value:"Routing Component",id:"routing-component",children:[]}],s={rightToc:c},l="wrapper";function u(e){var n=e.components,t=r(e,["components"]);return Object(a.b)(l,o({},s,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Routing is a complex topic and many react projects have sprung up around\nrouting. scalajs react facades also provide routing libraries. You can use any\njavascript based routing librar you wish, such as\n",Object(a.b)("a",o({parentName:"p"},{href:"https://reacttraining.com/react-router"}),"react-router"),". To make it easier though\nwe have provided two levels of routing support."),Object(a.b)("h2",null,Object(a.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"lowest-level"})),Object(a.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#lowest-level"}),"#"),"Lowest Level"),Object(a.b)("p",null,"ReasonReact provides a small, ~100 line router, in the base distribution and\nthat small router code is also included in the scalajs-react implementation."),Object(a.b)("p",null,"The router establishes a simple callback mechanism when the URL changes and\nallows you to obtain the current URL as well as push a new URL state into the\nhistory object running in the browser."),Object(a.b)("p",null,"You can route to some hashes by doing something like the following:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-scala"}),'  sealed trait Action\n  case class Navigate(page: Page) extends Action\n  case object SomeOtherAction extends Action\n  \n  case class State(page: Page)\n\n  sealed trait Page\n  case object Home extends Page\n  case class AnotherPage(id: String) extends Page\n\n  val c = reducerComponent[State, Action]("MyComponent")\n  import c.ops._\n  \n  def apply() =\n   c.copy(new methods { \n     val initialState = () => State(Home)\n     \n     val reducer = (action, state, gen) => {\n       action match { \n         case Navigate(p) => gen.update(state.copy(page = p))\n         case SomeOtherAction = gen.skip // for demo purposes only\n       }\n     }\n\n     didMount = js.defined(self => {\n       val token = router.watchUrl{ url => \n         url match {\n           case Some("home") => self.send(Navigate(Home))\n           case Some("person") => self.send(Navigate(AnotherPage("person")))\n           case _ => self.send(Navigate(Home))\n         }\n       }\n       // prime the pump!\n       // ...don\'t forget this...\n       self.onUnmount(() => router.unwatchUrl(token)\n     })\n     \n     val render = self => {\n       self.state.page match { \n          case Home => "home"\n          case AnotherPage(id) => id\n       }\n     }\n       \n  })\n')),Object(a.b)("h2",null,Object(a.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"routing-component"})),Object(a.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#routing-component"}),"#"),"Routing Component"),Object(a.b)("p",null,'We have a provided a DOM agnostic router component and a specialization of that\nrouting component for the ReasonReact style router described in the previous\nsection. You can have as many RoutingComponents as you like in your application\nas there is no shared state between them. Think of these components as rendering\nbased on the URL and if you don\'t like the URL, return a "null" node which\neffectively turns off rendering for any children of the routing component.'),Object(a.b)("p",null,"You are free to use another routing strategy and plug that into\n",Object(a.b)("inlineCode",{parentName:"p"},"RoutingComponent"),"."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-scala"}),'// ReactionRouting\nimport react.router.browser._\n\n// App\nobject Routing {\n    import ReactionRouting._\n    // if using sparsetech.trail route matching library\n    val coolRoute = Root / Arg[String] / Arg[String]\n    val login = Root / "login"\n    \n    val config = ReactionConfig(rules(parts => {\n       parts.pathname match {\n          case coolRoute(entityName, entityId) => Render(() => SomeView(entityName, entityId))\n          case login(_) => Redirect("/login", RedirectMethod.Push)\n          case _ => Render(() => UnknownPage(parts))\n       }\n       // or do something custom\n       parts.pathname match {\n          case parts if(parts.map(_.hash == "blah").getOrElse(false)) => Render(() => Blah)\n          case _ => Render(() => null)\n       }\n    }))\n}\n\ndef main() {\n    reactdom.createAndRenderWithId(\n      Fabric(new Fabric.Props {})(\n        ReactionRouting(Routing.config)\n      ),\n      "container"\n     )\n    // kick things off\n    react.router.push("")\n}\n')),Object(a.b)("p",null,'You will want to use a real "matching" library like\n',Object(a.b)("a",o({parentName:"p"},{href:"https://github.com/sparsetech/trail"}),"trail"),' to match on the URL and provide\n"route-to-page" routing processing in your config.'))}u.isMDXComponent=!0},89:function(e,n,t){"use strict";t.d(n,"a",function(){return c}),t.d(n,"b",function(){return p});var a=t(0),o=t.n(a),r=o.a.createContext({}),i=function(e){var n=o.a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},c=function(e){var n=i(e.components);return o.a.createElement(r.Provider,{value:n},e.children)},s="mdxType",l={inlineCode:"code",wrapper:function(e){return o.a.createElement(o.a.Fragment,{},e.children)}},u=function(e){var n=e.components,t=e.mdxType,a=e.originalType,r=e.parentName,c=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),s=i(n);return o.a.createElement(s[r+"."+t]||s[t]||l[t]||a,n?Object.assign({},c,{components:n}):c)};function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=u;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c[s]="string"==typeof e?e:a,i[1]=c;for(var p=2;p<r;p++)i[p]=t[p];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);